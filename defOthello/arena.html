<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content='yes'>
    <meta charset="UTF-8">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="Last-Modified" content="0">
    <meta http-equiv="Cache-Control" content="no-cache, mustrevalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <title>Konekti Video</title>
    <script type='text/javascript' src='https://jgomezpe.github.io/konekti/src/konekti.js'></script>;
    <script>src = "../agentes/sergio.js"</script>
</head>

<body>

    <script>

        Konekti.uses('header', 'navbar', 'canvas')

        class Agent {
            constructor() { }

            init(color, board, time = 20000) {
                this.color = color
                this.time = time
                this.size = board.length
            }

            // Must return a list representing the row and column to put a piece
            // row column
            // | |
            compute(board, time) { return [0, 0] }
        }

        /*
        * A class for board operations (it is not the board but a set of operations over it)
        */
        class Board {
            constructor() { }
            // Initializes a board of the given size. A board is a matrix of size*size of characters ' ', 'B', or 'W'
            init(size) {
                var board = []
                for (var i = 0; i < size; i++) {
                    board[i] = []
                    for (var j = 0; j < size; j++)
                        board[i][j] = ' '
                }
                var m = Math.floor(size / 2) - 1
                board[m][m] = 'W'
                board[m][m + 1] = 'B'
                board[m + 1][m + 1] = 'W'
                board[m + 1][m] = 'B'
                return board
            }
            // Deep clone of a board the reduce risk of damaging the real board
            clone(board) {
                var size = board.length
                var b = []
                for (var i = 0; i < size; i++) {
                    b[i] = []
                    for (var j = 0; j < size; j++)
                        b[i][j] = board[i][j]
                }
                return b
            }

            // Determines if a piece of the 'color' can be set at position 'i', 'j' (row, column, respectively)
            check(board, color, i, j) {
                var size = board.length
                if (board[i][j] != ' ') return false
                var rcolor = color == 'W' ? 'B' : 'W'
                //left
                var k = j - 1
                while (k >= 0 && board[i][k] == rcolor) k--
                if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color) return true
                //right
                k = j + 1
                while (k < size && board[i][k] == rcolor) k++
                if (k < size && Math.abs(k - j) > 1 && board[i][k] == color) return true
                //up
                k = i - 1
                while (k >= 0 && board[k][j] == rcolor) k--
                if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color) return true
                //down
                k = i + 1
                while (k < size && board[k][j] == rcolor) k++
                if (k < size && Math.abs(k - i) > 1 && board[k][j] == color) return true
                //left-top
                k = i - 1
                var l = j - 1
                while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
                    k--
                    l--
                }
                if (k >= 0 && l >= 0 && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) return true
                //left-bottom
                k = i + 1
                l = j - 1
                while (k < size && l >= 0 && board[k][l] == rcolor) {
                    k++
                    l--
                }
                if (k < size && l >= 0 && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) return true
                //right-top
                k = i - 1
                l = j + 1
                while (k >= 0 && l < size && board[k][l] == rcolor) {
                    k--
                    l++
                }
                if (k >= 0 && l < size && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) return true
                //right-bottom
                k = i + 1
                l = j + 1
                while (k < size && l < size && board[k][l] == rcolor) {
                    k++
                    l++
                }
                if (k < size && l < size && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) return true
                return false
            }

            // Computes all the valid moves for the given 'color'
            valid_moves(board, color) {
                var moves = []
                var size = board.length
                for (var i = 0; i < size; i++) {
                    for (var j = 0; j < size; j++)
                        if (this.check(board, color, i, j)) moves.push([i, j])
                }
                return moves
            }

            // Determines if a piece of 'color' can be set
            can_play(board, color) {
                var size = board.length
                var i = 0
                while (i < size) {
                    var j = 0
                    while (j < size && !this.check(board, color, i, j)) j++
                    if (j < size) return true
                    i++
                }
                return false
            }

            // Computes the new board when a piece of 'color' is set at position 'i', 'j' (row, column respectively)
            // If it is an invalid movement stops the game and declares the other 'color' as winner
            move(board, i, j, color) {
                var white_move = color == 'W'
                var size = board.length
                if (board[i][j] != ' ') return false
                board[i][j] = color
                var rcolor = color == 'W' ? 'B' : 'W'
                var flag = false
                //left
                var k = j - 1
                while (k >= 0 && board[i][k] == rcolor) k--
                if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color) {
                    flag = true
                    k = j - 1
                    while (k > 0 && board[i][k] == rcolor) {
                        board[i][k] = color
                        k--
                    }
                }
                //right
                k = j + 1
                while (k < size && board[i][k] == rcolor) k++
                if (k < size && Math.abs(k - j) > 1 && board[i][k] == color) {
                    flag = true
                    k = j + 1
                    while (k < size && board[i][k] == rcolor) {
                        board[i][k] = color
                        k++
                    }
                }
                //up
                k = i - 1
                while (k >= 0 && board[k][j] == rcolor) k--
                if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color) {
                    flag = true
                    k = i - 1
                    while (k >= 0 && board[k][j] == rcolor) {
                        board[k][j] = color
                        k--
                    }
                }
                //down
                k = i + 1
                while (k < size && board[k][j] == rcolor) k++
                if (k < size && Math.abs(k - i) > 1 && board[k][j] == color) {
                    flag = true
                    k = i + 1
                    while (k < size && board[k][j] == rcolor) {
                        board[k][j] = color
                        k++
                    }
                }
                //left-top
                k = i - 1
                l = j - 1
                while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
                    k--
                    l--
                }
                if (k >= 0 && l >= 0 && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) {
                    flag = true
                    k = i - 1
                    l = j - 1
                    while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
                        board[k][l] = color
                        k--
                        l--
                    }
                }
                //left-bottom
                var k = i + 1
                var l = j - 1
                while (k < size && l >= 0 && board[k][l] == rcolor) {
                    k++
                    l--
                }
                if (k < size && l >= 0 && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) {
                    flag = true
                    var k = i + 1
                    var l = j - 1
                    while (k < size && l >= 0 && board[k][l] == rcolor) {
                        board[k][l] = color
                        k++
                        l--
                    }
                }
                //right-top
                var k = i - 1
                var l = j + 1
                while (k >= 0 && l < size && board[k][l] == rcolor) {
                    k--
                    l++
                }
                if (k >= 0 && l < size && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) {
                    flag = true
                    var k = i - 1
                    var l = j + 1
                    while (k >= 0 && l < size && board[k][l] == rcolor) {
                        board[k][l] = color
                        k--
                        l++
                    }
                }
                //right-bottom
                var k = i + 1
                var l = j + 1
                while (k < size && l < size && board[k][l] == rcolor) {
                    k++
                    l++
                }
                if (k < size && l < size && Math.abs(k - i) > 1 && Math.abs(l - j) > 1 && board[k][l] == color) {
                    flag = true
                    var k = i + 1
                    var l = j + 1
                    while (k < size && l < size && board[k][l] == rcolor) {
                        board[k][l] = color
                        k++
                        l++
                    }
                }
                return flag
            }

            // Computes the winner in terms of number of pieces in the board
            winner(board, white, black) {
                var size = board.length
                var W = 0
                var B = 0
                for (var i = 0; i < size; i++)
                    for (var j = 0; j < size; j++)
                        if (board[i][j] == 'W') W++
                        else if (board[i][j] == 'B') B++
                var msg = ' Pieces count W:' + W + ' B:' + B
                if (W == B) return 'Draw ' + msg
                return ((W > B) ? white : black) + msg
            }

            // Draw the board on the canvas
            print(board) {
                var size = board.length
                // Commands to be run (left as string to show them into the editor)
                var grid = []
                for (var i = 0; i < size; i++) {
                    for (var j = 0; j < size; j++)
                        grid.push({ "command": "translate", "y": i, "x": j, "commands": [{ "command": "-" }, { "command": board[i][j] }] })
                }

                var commands = { "r": true, "x": 1.0 / size, "y": 1.0 / size, "command": "fit", "commands": grid }
                Konekti.client['canvas'].setText(commands)
            }
        }

        /*
        * Player's Code (Must inherit from Agent)
        * This is an example of a random player agent
        */
        class RandomPlayer extends Agent {
            constructor() {
                super()
                this.board = new Board()
            }

            compute(board, time) {
                var moves = this.board.valid_moves(board, this.color)
                var index = Math.floor(moves.length * Math.random())
                for (var i = 0; i < 50000000; i++) { } // Making it very slow to test time restriction
                return moves[index]
            }
        }
        class EEAPlayer extends Agent {
            constructor() {
                super();
                this.board = new Board();
            }

            compute(board, time) {
                const startTime = performance.now();
                const depth = 4;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                const bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity
                ).move;

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                console.log("Elapsed Time:", elapsedTime);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    return {
                        score: this.evaluate(board, this.color),
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);
                    this.board.move(newBoard, row, col, color);

                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }

            evaluate(board, color) {
                // Simple evaluation function that counts the number of pieces for the player
                // and subtracts the number of pieces for the opponent
                let playerScore = 0;
                let opponentScore = 0;

                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore++;
                        } else if (board[i][j] !== " ") {
                            opponentScore++;
                        }
                    }
                }

                return playerScore - opponentScore;
            }
        }
        class EEAPlayer0 extends Agent {
            constructor() {
                super();
                this.board = new Board();
            }

            compute(board, time) {
                const startTime = performance.now();
                const depth = 4;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                const bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity
                ).move;

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                console.log("Elapsed Time:", elapsedTime);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    return {
                        score: this.evaluate(board, this.color),
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);
                    this.board.move(newBoard, row, col, color);

                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }

            evaluate(board, color) {
                // Simple evaluation function that counts the number of pieces for the player
                // and subtracts the number of pieces for the opponent
                let playerScore = 0;
                let opponentScore = 0;

                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore++;
                        } else if (board[i][j] !== " ") {
                            opponentScore++;
                        }
                    }
                }
                return playerScore - opponentScore;
            }
        }
        class CustomPlayer1 extends Agent {
            constructor() {
                super()
                this.board = new Board();
                this.turns = (this.player === 'W' ? 1 : 0);
                this.fase1 = 0;
                this.fase2 = 0;
                this.fase3 = 0;

            }

            compute(board, time) {
                this.turns += 2;
                this.fase1 = Math.floor((Math.pow(this.size, 2) - 4) / 3);
                this.fase2 = Math.floor(((Math.pow(this.size, 2) - 4) / 3) * 2);
                this.fase3 = Math.floor((Math.pow(this.size, 2)));
                const matrix = this.convert(board);
                return this.alphaBetaMove(matrix, (this.color === 'W' ? 1 : -1), 1);

            }

            copyAndExecute(board, row, col, player) {
                let newBoard = []
                for (let i = 0; i < this.size; i++) {
                    newBoard = [...newBoard, board[i].slice()];
                }


                let j, i, k, l, acumulado = 0;
                //to left
                for (j = col - 1; j >= 0; j--) {
                    if (col - 1 >= 0) {
                        if (newBoard[row][col - 1] === player || newBoard[row][col - 1] === 0) break;
                    }
                    if (newBoard[row][j] === player && j !== col - 1) {
                        for (k = col - 1; k > j; k--)newBoard[row][k] = player;
                        break;
                    }
                    if (newBoard[row][j] === 0 && j !== col - 1) {
                        break;
                    }
                }
                //to right
                for (j = col + 1; j < this.size; j++) {
                    if (col + 1 < this.size) {
                        if (newBoard[row][col + 1] === player || newBoard[row][col + 1] === 0) break;
                    }
                    if (newBoard[row][j] === player && j !== col + 1) {
                        for (k = col + 1; k < j; k++)newBoard[row][k] = player;
                        break;
                    }
                    if (newBoard[row][j] === 0 && j !== col + 1) break;
                }
                //to up
                for (i = row - 1; i >= 0; i--) {
                    if (row - 1 >= 0) {
                        if (newBoard[row - 1][col] === player || newBoard[row - 1][col] === 0) break;
                    }
                    if (newBoard[i][col] === player && i !== row - 1) {
                        for (l = row - 1; l > i; l--)newBoard[l][col] = player;
                        break;
                    }
                    if (newBoard[i][col] === 0 && i !== row - 1) break;
                }
                //to down
                for (i = row + 1; i < this.size; i++) {
                    if (row + 1 < this.size) {
                        if (newBoard[row + 1][col] === player || newBoard[row + 1][col] === 0) break;
                    }
                    if (newBoard[i][col] === player && i !== row + 1) {
                        for (l = row + 1; l < i; l++)newBoard[l][col] = player;
                        break;
                    }
                    if (newBoard[i][col] === 0 && i !== row + 1) break;

                }

                //left-up
                j = col - 2;
                i = row - 2;

                while (j >= 0 && i >= 0) {

                    if (row - 1 >= 0 && col - 1 >= 0) {
                        if (newBoard[row - 1][col - 1] === player || newBoard[row - 1][col - 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row - 1
                        k = col - 1
                        while (l > i && k > j) {
                            newBoard[l][k] = player
                            l--;
                            k--;
                        }
                    };
                    if (newBoard[i][j] === 0) break;
                    j--;
                    i--;
                }

                //left-down
                j = col - 2;
                i = row + 2;

                while (j >= 0 && i < this.size) {

                    if (row - 1 < this.size && col - 1 >= 0) {
                        if (newBoard[row + 1][col - 1] === player || newBoard[row + 1][col - 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row + 1
                        k = col - 1
                        while (l < i && k > j) {
                            newBoard[l][k] = player
                            l++;
                            k--;
                        }
                    }
                    if (newBoard[i][j] === 0) break;
                    j--;
                    i++;
                }
                //right-down
                j = col + 2;
                i = row + 2;

                while (j < this.size && i < this.size) {

                    if (row + 1 < this.size && col + 1 < this.size) {
                        if (newBoard[row + 1][col + 1] === player || newBoard[row + 1][col + 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row + 1
                        k = col + 1
                        while (l < i && k < j) {
                            newBoard[l][k] = player
                            l++;
                            k++;
                        }
                    }
                    if (newBoard[i][j] === 0) break;
                    j++;
                    i++;
                }

                //right-up
                j = col + 2;
                i = row - 2;

                while (j < this.size && i > 0) {

                    if (row - 1 >= 0 && col + 1 < this.size) {
                        if (newBoard[row - 1][col + 1] === player || newBoard[row - 1][col + 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row - 1
                        k = col + 1
                        while (l > i && k < j) {
                            newBoard[l][k] = player;
                            l--;
                            k++;
                        }
                    }
                    if (newBoard[i][j] === 0) break;
                    j++;
                    i--;
                }

                newBoard[row][col] = player;

                return newBoard;
            }
            alphaBetaMove(board, player, level) {
                if (this.terminal(board) === true) return []
                if (player === 1) {
                    let bestMove, temp;
                    let value = -Infinity;
                    let moves = this.mobility_moves(board, 1);
                    if (moves.length === 0) {
                        this.alphaBetaSearch(board, -1, -Infinity, Infinity, level + 1)
                    } else {
                        for (var i = 0; i < moves.length; i++) {
                            let temp = value;
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, 1);
                            console.log('En alpha beta + : ' + player)
                            console.log(newBoard)
                            value = Math.max(value, this.alphaBetaSearch(newBoard, -1, -Infinity, Infinity, level + 1))
                            if (value > temp) bestMove = moves[i]
                        }
                        return bestMove
                    }
                } else {
                    let bestMove, temp
                    let value = Infinity
                    let moves = this.mobility_moves(board, -1)
                    if (moves.length === 0) {
                        this.alphaBetaSearch(board, 1, -Infinity, Infinity, level + 1)
                    } else {

                        for (var i = 0; i < moves.length; i++) {
                            let temp = value
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, -1);
                            value = Math.min(value, this.alphaBetaSearch(newBoard, 1, -Infinity, Infinity, level + 1))
                            if (value < temp) bestMove = moves[i]
                        }
                        return bestMove
                    }

                }
            }

            alphaBetaSearch(board, player, alpha, beta, level) {
                let i;
                if (this.turns < this.fase1 && level === 3 || this.size <= 4) return this.heuristicValue2(board, player)
                if (this.turns >= this.fase1 && this.turns < this.fase2 && level === 3) return this.heuristicValue5(board, player)
                if ((this.turns >= this.fase2 && level === 4) || this.terminal(board)) return this.heuristicValue4(board, player)



                if (player === 1) {
                    let value = -Infinity
                    let moves = this.mobility_moves(board, 1)
                    if (moves.length === 0) {
                        return this.alphaBetaSearch(board, -1, alpha, beta, level + 1)
                    } else {
                        for (i = 0; i < moves.length; i++) {
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, player);
                            value = Math.max(value, this.alphaBetaSearch(newBoard, -1, alpha, beta, level + 1))
                            if (value >= beta) return value
                            alpha = Math.max(alpha, value)
                        }
                        return value
                    }
                } else {
                    let value = Infinity
                    let moves = this.mobility_moves(board, -1)
                    if (moves.length === 0) {
                        return this.alphaBetaSearch(board, 1, alpha, beta, level + 1)
                    } else {
                        for (i = 0; i < moves.length; i++) {
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, player);
                            value = Math.min(value, this.alphaBetaSearch(newBoard, 1, alpha, beta, level + 1))
                            if (value <= alpha) return value
                            beta = Math.min(beta, value)
                        }
                        return value
                    }

                }
            }

            // Determines if the state is terminal or not
            terminal(board) {

                var check_one = this.mobility(board, 1);
                var check_two = this.mobility(board, -1);
                return ((check_one === 0) && (check_two === 0));

            }
            mobility(board, player) {
                let moves = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++)
                        if (this.isMove(board, player, i, j)) {
                            moves++;
                        }
                }
                return moves;
            }

            mobility_moves(board, player) {
                let moves = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++)
                        if (this.isMove(board, player, i, j)) {
                            moves = [...moves, [i, j]];
                        }
                }
                return moves;
            }

            isMove(board, player, row, col) {
                let j, i;
                if (board[row][col] !== 0) return false;

                //to left
                for (j = col - 1; j >= 0; j--) {
                    if (col - 1 >= 0) {
                        if (board[row][col - 1] === player || board[row][col - 1] === 0) break;
                    }
                    if (board[row][j] === player && j !== col - 1) return true;
                    if (board[row][j] === 0 && j !== col - 1) break;
                }
                //to right
                for (j = col + 1; j < this.size; j++) {
                    if (col + 1 < this.size) {
                        if (board[row][col + 1] === player || board[row][col + 1] === 0) break;
                    }
                    if (board[row][j] === player && j !== col + 1) return true;
                    if (board[row][j] === 0 && j !== col + 1) break;
                }
                //to up
                for (i = row - 1; i >= 0; i--) {
                    if (row - 1 >= 0) {
                        if (board[row - 1][col] === player || board[row - 1][col] === 0) break;
                    }
                    if (board[i][col] === player && i !== row - 1) return true;
                    if (board[i][col] === 0 && i !== row - 1) break;
                }
                //to down
                for (i = row + 1; i < this.size; i++) {
                    if (row + 1 < this.size) {
                        if (board[row + 1][col] === player || board[row + 1][col] === 0) break;
                    }
                    if (board[i][col] === player && i !== row + 1) return true;
                    if (board[i][col] === 0 && i !== row + 1) break;

                }

                //left-up
                j = col - 2;
                i = row - 2;

                while (j >= 0 && i >= 0) {

                    if (row - 1 >= 0 && col - 1 >= 0) {
                        if (board[row - 1][col - 1] === player || board[row - 1][col - 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true }
                    if (board[i][j] === 0) break;
                    j--;
                    i--;
                }

                //left-down
                j = col - 2;
                i = row + 2;

                while (j >= 0 && i < this.size) {

                    if (row - 1 < this.size && col - 1 >= 0) {
                        if (board[row + 1][col - 1] === player || board[row + 1][col - 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true };
                    if (board[i][j] === 0) break;
                    j--;
                    i++;
                }
                //right-down
                j = col + 2;
                i = row + 2;

                while (j < this.size && i < this.size) {

                    if (row + 1 < this.size && col + 1 < this.size) {
                        if (board[row + 1][col + 1] === player || board[row + 1][col + 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true };
                    if (board[i][j] === 0) break;
                    j++;
                    i++;
                }

                //right-up
                j = col + 2;
                i = row - 2;

                while (j < this.size && i > 0) {

                    if (row - 1 >= 0 && col + 1 < this.size) {
                        if (board[row - 1][col + 1] === player || board[row - 1][col + 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true };
                    if (board[i][j] === 0) break;
                    j++;
                    i--;
                }



                return false;
            }

            inner_coin(board, i, j) {
                if (i - 1 > 0) {
                    if (j - 1 > 0) if (board[i - 1][j - 1] === 0) return false;
                    if (board[i - 1][j] === 0) return false;
                    if (j + 1 < this.size) if (board[i - 1][j + 1] === 0) return false;
                }
                if (j - 1 > 0) if (board[i][j - 1] === 0) return false;
                if (j + 1 < this.size) if (board[i][j + 1] === 0) return false;
                if (i + 1 < this.size) {
                    if (j - 1 > 0) if (board[i + 1][j - 1] === 0) return false;
                    if (board[i + 1][j] === 0) return false;
                    if (j + 1 < this.size) if (board[i + 1][j + 1] === 0) return false;
                }
                return true

            }

            // In case of terminal state returns the value for terminal state


            convert(board) {
                let matrix = [];
                for (let i = 0; i < this.size; i++) {
                    matrix = [...matrix, Array(this.size).fill(0)]
                }
                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board.length; j++) {
                        if (board[i][j] === '') matrix[i][j] = 0;
                        if (board[i][j] === 'W') matrix[i][j] = 1;
                        if (board[i][j] === 'B') matrix[i][j] = -1;
                    }
                }
                //console.log(matrix);
                return matrix;
            }

            heuristicValue2(board, player) {
                return (this.mobility(board, player) - this.mobility(board, player * -1)) * player
            }
            heuristicValue3(player) {
                let score = 0

                for (let i = 0; i < 8; i++) {
                    for (let j = 1; j < 8; j++) {
                        score += (this.numberMatrix[i][j] * this.POSITION_SCORES_2[i][j])
                    }
                }
                let mobility_1 = this.mobility(1)
                let mobility_2 = this.mobility(-1)

                if (player === 1) {
                    return (score) + 2 * (mobility_1 - mobility_2)
                } else {
                    return ((score * -1)) + 2 * (mobility_1 - mobility_2)
                }
            }

            heuristicValue4(board, player) {
                let count = 0
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (board[i][j] == player) {
                            count++;
                        }
                    }
                }
                return count * player;
            }

            heuristicValue5(board, player) {
                let value = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (board[i][j] === player && this.inner_coin(board, i, j)) {
                            value++;
                        }
                    }
                }
                return value * player;
            }

        }
        class CustomPlayer extends Agent {
            constructor() {
                super()
                this.board = new Board()
                this.n = this.board.length;
                this.turns = (this.player === 'W' ? 1 : 0);
                this.POSITION_SCORES =
                    [[25, 0, 6, 5, 5, 6, 0, 25],
                    [0, 0, 1, 1, 1, 1, 0, 0],
                    [6, 1, 4, 3, 3, 4, 1, 6],
                    [5, 1, 3, 2, 2, 3, 1, 5],
                    [5, 1, 3, 2, 2, 3, 1, 5],
                    [6, 1, 4, 3, 3, 4, 1, 6],
                    [0, 0, 1, 1, 1, 1, 0, 0],
                    [25, 0, 6, 5, 5, 6, 0, 25]]
                this.POSITION_SCORES_2 =
                    [[0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 2, 2, 2, 2, 0, 0],
                    [0, 2, 12, 4, 4, 12, 2, 0],
                    [0, 2, 4, 8, 8, 4, 2, 0],
                    [0, 2, 4, 8, 8, 4, 2, 0],
                    [0, 2, 12, 4, 4, 12, 2, 0],
                    [0, 0, 2, 2, 2, 2, 2, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]]
                this.levelDepth = 0
                this.numberMatrix = [[0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0]]
            }

            compute(board, time) {
                this.turns += 2;
                return this.alphaBetaMove(board, this.color, this.turns)
            }
            alphaBetaMove(board, player, level) {
                if (this.terminal(board) == true) return []
                if (player == 'W') {
                    let bestMove, temp
                    let value = -Infinity
                    let moves = this.board.valid_moves(board, 'W')
                    if (moves.length == 0) {
                        this.alphaBetaSearch(board, 'B', -Infinity, Infinity, level + 1)
                    } else {
                        for (var i = 0; i < moves.length; i++) {
                            temp = value
                            board[moves[i][0]][moves[i][1]] = 'W'
                            value = Math.max(value, this.alphaBetaSearch(board, 'B', -Infinity, Infinity, level + 1))
                            board[moves[i][0]][moves[i][1]] = ''
                            if (value > temp) bestMove = moves[i]
                        }
                        return bestMove
                    }
                } else {
                    let bestMove, temp
                    let value = Infinity
                    let moves = this.board.valid_moves(board, 'B')
                    if (moves.length == 0) {
                        this.alphaBetaSearch(board, 'W', -Infinity, Infinity, level + 1)
                    } else {

                        for (var i = 0; i < moves.length; i++) {
                            temp = value
                            board[moves[i][0]][moves[i][1]] = 'B'
                            value = Math.min(value, this.alphaBetaSearch(board, 'W', -Infinity, Infinity, level + 1))
                            board[moves[i][0]][moves[i][1]] = ''
                            if (value < temp) bestMove = moves[i]
                        }
                        return bestMove
                    }

                }
            }

            alphaBetaSearch(board, player, alpha, beta, level) {
                let i;
                //if(this.turns < 5) return this.heuristicValue2(board,player)
                //if(this.turns < 12 && level === this.turns + 2) return this.heuristicValue2(board,player)
                //if(this.turns < 13 && level === this.turns + 4 ) return this.heuristicValue4(board,player)
                if (this.turns > 50 && this.terminal(board)) return this.heuristicValue4(board, player)
                if (this.terminal(board) === true) return this.heuristicValue(board, player)
                //if (this.terminal(board) === true) return this.heuristicValue4(board, player)


                if (player === 'W') {
                    let value = -Infinity
                    let moves = this.board.valid_moves(board, 'W')
                    if (moves.length == 0) {
                        return this.alphaBetaSearch(board, 'B', alpha, beta)
                    } else {
                        for (i = 0; i < moves.length; i++) {
                            board[moves[i][0]][moves[i][1]] = 'W'
                            value = Math.max(value, this.alphaBetaSearch(board, 'B', alpha, beta))
                            board[moves[i][0]][moves[i][1]] = ''
                            if (value >= beta) return value
                            alpha = Math.max(alpha, value)
                        }
                        return value
                    }
                } else {
                    let value = Infinity
                    let moves = this.board.valid_moves(board, 'B')
                    if (moves.length === 0) {
                        return this.alphaBetaSearch(board, 'W', alpha, beta)
                    } else {
                        for (i = 0; i < moves.length; i++) {
                            board[moves[i][0]][moves[i][1]] = 'B'
                            value = Math.min(value, this.alphaBetaSearch(board, 'W', alpha, beta))
                            board[moves[i][0]][moves[i][1]] = ''
                            if (value <= alpha) return value
                            beta = Math.min(beta, value)
                        }
                        return value
                    }

                }
            }

            // Determines if the state is terminal or not
            terminal(board) {
                var check_one = this.board.valid_moves(board, 'W')
                var check_two = this.board.valid_moves(board, 'B')
                return ((check_one.length === 0) && (check_two.length === 0))
            }

            // In case of terminal state returns the value for terminal state
            heuristicValue(board, player) {
                this.convert(board)
                let score = 0

                for (let i = 0; i < 8; i++) {
                    for (let j = 1; j < 8; j++) {
                        score += (this.numberMatrix[i][j] * this.POSITION_SCORES[i][j])
                    }
                }
                for (let i = 0; i < 8; i++) {
                    let row_pieces = [(this.numberMatrix[i][0])];
                    let col_pieces = [(this.numberMatrix[0][i])];
                    for (let j = 1; j < 8; j++) {
                        if (row_pieces[row_pieces.length - 1] * this.numberMatrix[i][j] > 0) {
                            row_pieces[row_pieces.length - 1] += this.numberMatrix[i][j]
                        } else {
                            row_pieces.push(this.numberMatrix[i][j])
                        }
                        if (col_pieces[col_pieces.length - 1] * this.numberMatrix[i][j] > 0) {
                            col_pieces[col_pieces.length - 1] += this.numberMatrix[i][j]
                        } else {
                            col_pieces.push(this.numberMatrix[i][j])
                        }
                        if (row_pieces.length >= 3) {
                            for (let j = 1; j < row_pieces.length - 1; j++) {
                                if (row_pieces[j] != 0) {
                                    if (row_pieces[j - 1] * row_pieces[j + 1] == 0 && row_pieces[j - 1] + row_pieces[j + 1] != 0) {
                                        score -= row_pieces[j] * 1;
                                    }
                                }
                            }
                        }
                        if (col_pieces.length >= 3) {
                            for (let j = 1; j < col_pieces.length - 1; j++) {
                                if (col_pieces[j] !== 0) {
                                    if (col_pieces[j - 1] * col_pieces[j + 1] === 0 && col_pieces[j - 1] + col_pieces[j + 1] != 0) {
                                        score -= col_pieces[j] * 1
                                    }
                                }
                            }
                        }
                    }

                }
                /*
        
                if (this.numberMatrix[0][0] === 0)score -= ((this.numberMatrix[1][0] + this.numberMatrix[0][1] + this.numberMatrix[1][1])*3)
                if (this.numberMatrix[0][7] === 0)score -= ((this.numberMatrix[1][7] + this.numberMatrix[0][6] + this.numberMatrix[1][6])*3)
                if (this.numberMatrix[7][0] === 0)score -= ((this.numberMatrix[7][1] + this.numberMatrix[6][0] + this.numberMatrix[6][1])*3)
                if (this.numberMatrix[7][7] === 0)score -= ((this.numberMatrix[6][7] + this.numberMatrix[7][6] + this.numberMatrix[6][6])*3)
                
                 */



                if (player == 'W') {
                    var check_one = this.board.valid_moves(board, 'W')
                    var check_two = this.board.valid_moves(board, 'B')
                    //return (score + 2*(check_one.length - check_two.length))
                    return score * -1
                } else {
                    var check_one = this.board.valid_moves(board, 'W')
                    var check_two = this.board.valid_moves(board, 'B')
                    //return ((score*-1) + 2*(check_one.length - check_two.length))
                    return score
                }
            }

            convert(board) {
                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board.length; j++) {
                        if (board[i][j] == '') this.numberMatrix[i][j] = 0;
                        if (board[i][j] == 'W') this.numberMatrix[i][j] = 1;
                        if (board[i][j] == 'B') this.numberMatrix[i][j] = -1;
                    }
                }
            }
            heuristicValue2(board, player) {
                if (player == 'W') {
                    return (this.board.valid_moves(board, 'W').length)
                } else {
                    return (this.board.valid_moves(board, 'B').length * -1)
                }

            }
            heuristicValue3(board, player) {
                this.convert(board)
                let score = 0

                for (let i = 0; i < 8; i++) {
                    for (let j = 1; j < 8; j++) {
                        score += (this.numberMatrix[i][j] * this.POSITION_SCORES_2[i][j])
                    }
                }
                let mobility_1 = this.board.valid_moves(board, 'W').length
                let mobility_2 = this.board.valid_moves(board, 'B').length

                if (player == 'W') {
                    return (score) + 2 * (mobility_1 - mobility_2)
                } else {
                    return ((score * -1)) + 2 * (mobility_1 - mobility_2)
                }
            }
            heuristicValue4(board, player) {
                var minormax = player == 'W' ? 1 : -1
                var size = board.length
                var W = 0
                var B = 0
                for (var i = 0; i < size; i++)
                    for (var j = 0; j < size; j++)
                        if (board[i][j] == 'W') W++
                        else if (board[i][j] == 'B') B++

                return (W - B)
            }
        }
        class EEAPlayerPRO extends Agent {
            constructor() {
                super();
                this.board = new Board();
            }

            compute(board, time) {
                const startTime = performance.now();
                const depth = 5;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                const bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity
                ).move;

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                console.log("Elapsed Time:", elapsedTime);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    return {
                        score: this.evaluate(board, this.color),
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);
                    this.board.move(newBoard, row, col, color);

                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }

            evaluate(board, color) {
                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 0.1; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;
                let playerCorners = 0;
                let opponentCorners = 0;
                let playerEdges = 0;
                let opponentEdges = 0;

                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += pieceValue;
                            if (
                                (i === 0 && j === 0) ||
                                (i === 0 && j === board[i].length - 1) ||
                                (i === board.length - 1 && j === 0) ||
                                (i === board.length - 1 && j === board[i].length - 1)
                            ) {
                                playerCorners += cornerValue;
                            } else if (
                                i === 0 ||
                                j === 0 ||
                                i === board.length - 1 ||
                                j === board[i].length - 1
                            ) {
                                playerEdges += edgeValue;
                            }
                        } else if (board[i][j] !== " ") {
                            opponentScore += pieceValue;


                            if (
                                (i === 0 && j === 0) ||
                                (i === 0 && j === board[i].length - 1) ||
                                (i === board.length - 1 && j === 0) ||
                                (i === board.length - 1 && j === board[i].length - 1)
                            ) {
                                opponentCorners += cornerValue;
                            } else if (
                                i === 0 ||
                                j === 0 ||
                                i === board.length - 1 ||
                                j === board[i].length - 1
                            ) {
                                opponentEdges += edgeValue;
                            }
                        }
                    }
                }
                const playerScoreTotal =
                    playerScore +
                    playerCorners +
                    playerEdges;
                const opponentScoreTotal =
                    opponentScore +
                    opponentMoves * mobilityValue +
                    opponentCorners +
                    opponentEdges;

                return playerScoreTotal - opponentScoreTotal;
            }
        }
        class EEAPlayerG extends Agent {
            constructor() {
                super();
                this.board = new Board();
                this.POSITION_SCORES = [];
            }

            compute(board, time) {
                function crearMCompleta() {
                    let TAMANO = board.length;
                    let impar = false;
                    if (TAMANO % 2 != 0) {
                        impar = true;
                        TAMANO += 1;
                    }
                    const NUMANILLOS = TAMANO / 2;
                    const anillos = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    let caso1 = false;
                    if (TAMANO % 4 == 0) {
                        caso1 = true;
                    }
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let numPartesAnillo = (i + 1);
                        for (let j = 0; j < numPartesAnillo; j++) {
                            //El tamao del tablero es divisible por 4? 
                            if (caso1) {
                                if (i % 2 != 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 == 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            }
                            //El tamao del tablero no es divisible por 4?
                            if (!caso1) {
                                if (i % 2 == 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 != 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            } else if (i == 0) {
                                anillos[0][j] = 2;
                            } if (i == NUMANILLOS - 1) {
                                anillos[i][0] = (NUMANILLOS + 1) * 5;
                                anillos[i][1] = 0;
                                anillos[i][2] = numPartesAnillo + 2;
                            }
                        }
                    }
                    //Formar una cuarta parte de la matriz
                    const cuarto = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        for (let j = NUMANILLOS - 1; j >= 0; j--) {
                            cuarto[i][j] = anillos[NUMANILLOS - j - 1][i - j];
                            cuarto[j][i] = anillos[NUMANILLOS - j - 1][i - j];
                        }
                    }
                    const completa = new Array(TAMANO).fill().map(_ => new Array(TAMANO).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let reves = cuarto[i].slice().reverse()
                        let fila = (cuarto[i]).concat(reves);

                        if (impar) {
                            fila.splice(NUMANILLOS - 1, 1);
                        }
                        completa[i] = fila//ncuarto[i].reverse().concat(ncuarto[i]);        
                        completa[TAMANO - i - 1] = fila
                    }
                    if (impar) {
                        completa.splice(NUMANILLOS - 1, 1)
                    }
                    return completa;
                }

                const moves = this.board.valid_moves(board, color);
                this.POSITION_SCORES = crearMCompleta();



                const startTime = performance.now();
                const depth = 4;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                let bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity
                ).move;
                if (bestMove == null) {
                    bestMove = moves[0];
                }

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                //console.log("Elapsed Time:", elapsedTime);
                console.log(this.c);
                return bestMove;
            }

            minimax(board, color, depth, alpha, beta) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length < 4) {//""=== 0) {
                    return {
                        score: this.evaluate(board, this.color),
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);
                    this.board.move(newBoard, row, col, color);

                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }

            evaluate(board, color) {

                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 2; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;
                let playerCorners = 0;
                let opponentCorners = 0;
                let playerEdges = 0;
                let opponentEdges = 0;

                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += this.POSITION_SCORES[i][j];
                            playerMoves += this.board.valid_moves(board, color).length;
                        } else if (board[i][j] !== " ") {
                            opponentScore += 1//this.POSITION_SCORES[i][j];
                            playerMoves += this.board.valid_moves(board, color).length;
                        }
                    }
                }


                const playerScoreTotal =
                    playerScore +
                    playerMoves * mobilityValue

                const opponentScoreTotal =
                    opponentScore +
                    opponentMoves * mobilityValue

                return playerScoreTotal - opponentScoreTotal;
            }
        }
        class EEAPlayerG1 extends Agent {
            constructor() {
                super();
                this.board = new Board();
                this.POSITION_SCORES = [];
                this.c = 0;
            }

            compute(board, time) {
                function crearMCompleta() {
                    let TAMANO = board.length;
                    let impar = false;
                    if (TAMANO % 2 != 0) {
                        impar = true;
                        TAMANO += 1;
                    }
                    const NUMANILLOS = TAMANO / 2;
                    const anillos = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    let caso1 = false;
                    if (TAMANO % 4 == 0) {
                        caso1 = true;
                    }
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let numPartesAnillo = (i + 1);
                        for (let j = 0; j < numPartesAnillo; j++) {
                            //El tamao del tablero es divisible por 4? 
                            if (caso1) {
                                if (i % 2 != 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 == 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            }
                            //El tamao del tablero no es divisible por 4?
                            if (!caso1) {
                                if (i % 2 == 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 != 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            } else if (i == 0) {
                                anillos[0][j] = 2;
                            } if (i == NUMANILLOS - 1) {
                                anillos[i][0] = (NUMANILLOS + 1) * 5;
                                anillos[i][1] = 0;
                                anillos[i][2] = numPartesAnillo + 2;
                            }
                        }
                    }
                    //Formar una cuarta parte de la matriz
                    const cuarto = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        for (let j = NUMANILLOS - 1; j >= 0; j--) {
                            cuarto[i][j] = anillos[NUMANILLOS - j - 1][i - j];
                            cuarto[j][i] = anillos[NUMANILLOS - j - 1][i - j];
                        }
                    }
                    const completa = new Array(TAMANO).fill().map(_ => new Array(TAMANO).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let reves = cuarto[i].slice().reverse()
                        let fila = (cuarto[i]).concat(reves);

                        if (impar) {
                            fila.splice(NUMANILLOS - 1, 1);
                        }
                        completa[i] = fila//ncuarto[i].reverse().concat(ncuarto[i]);        
                        completa[TAMANO - i - 1] = fila
                    }
                    if (impar) {
                        completa.splice(NUMANILLOS - 1, 1)
                    }
                    return completa;
                }

                this.POSITION_SCORES = crearMCompleta();

                const startTime = performance.now();
                const depth = 4;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                const bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity
                ).move;

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                //console.log("Elapsed Time:", elapsedTime);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    return {
                        score: this.evaluate(board, this.color),
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);

                    //this.board.move(newBoard, row, col, color);
                    this.makeMove(newBoard, row, col, color);


                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }
            makeMove(board, row, col, color) {
                this.c += 1;
                let fliped = [];
                const TAMANO = board.length;
                const directions = [
                    [0, 1], // right
                    [0, -1], // left
                    [1, 0], // down
                    [-1, 0], // up
                    [1, 1], // diagonal down-right
                    [1, -1], // diagonal down-left
                    [-1, 1], // diagonal up-right
                    [-1, -1], // diagonal up-left
                ];
                board[row][col] = color
                var rcolor = color == 'W' ? 'B' : 'W'
                for (let i = 0; i < directions.length; i++) {
                    let temp = [];
                    const [deltaRow, deltaCol] = directions[i];
                    let currentRow = row + deltaRow;
                    let currentCol = col + deltaCol;
                    if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                        while (board[currentRow][currentCol] == rcolor) {
                            temp.push([currentRow, currentCol]);
                            if (currentRow + deltaRow < TAMANO && currentRow + deltaRow >= 0 && currentCol + deltaCol < TAMANO && currentCol + deltaCol >= 0) {
                                currentRow = currentRow + deltaRow;
                                currentCol = currentCol + deltaCol;
                            } else {
                                break;
                            }
                            if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                                if (board[currentRow][currentCol] == color) {
                                    fliped.push(temp);
                                    //Voltear las piezas
                                    for (let k = 0; k < temp.length; k++) {
                                        const [x, y] = temp[k];
                                        board[x][y] = color;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            evaluate(board, color) {
                console.log(1);
                let ocolor = "";
                if (color === "W") {
                    ocolor === "B";
                } else {
                    ocolor === "B";
                }

                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 2; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;
                let playerCorners = 0;
                let opponentCorners = 0;
                let playerEdges = 0;
                let opponentEdges = 0;

                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += this.POSITION_SCORES[i][j];
                        } else if (board[i][j] !== " ") {
                            opponentScore += 1//this.POSITION_SCORES[i][j];                            
                        }
                    }
                }
                playerMoves = this.board.valid_moves(board, color).length;
                opponentMoves = this.board.valid_moves(board, ocolor).length;

                const playerScoreTotal =
                    playerScore +
                    playerMoves * mobilityValue

                const opponentScoreTotal =
                    opponentScore +
                    opponentMoves * mobilityValue

                return playerScoreTotal - opponentScoreTotal;
            }
        }

        class EEAPlayerP extends Agent {
            constructor() {
                super();
                this.board = new Board();
                this.POSITION_SCORES = [];
                this.c = 0;
            }

            compute(board, time) {
                function crearMCompleta() {
                    let TAMANO = board.length;
                    let impar = false;
                    if (TAMANO % 2 != 0) {
                        impar = true;
                        TAMANO += 1;
                    }
                    const NUMANILLOS = TAMANO / 2;
                    const anillos = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    let caso1 = false;
                    if (TAMANO % 4 == 0) {
                        caso1 = true;
                    }
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let numPartesAnillo = (i + 1);
                        for (let j = 0; j < numPartesAnillo; j++) {
                            //El tamao del tablero es divisible por 4? 
                            if (caso1) {
                                if (i % 2 != 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 == 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            }
                            //El tamao del tablero no es divisible por 4?
                            if (!caso1) {
                                if (i % 2 == 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 != 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            } else if (i == 0) {
                                anillos[0][j] = 2;
                            } if (i == NUMANILLOS - 1) {
                                anillos[i][0] = (NUMANILLOS + 1) * 5;
                                anillos[i][1] = 0;
                                anillos[i][2] = numPartesAnillo + 2;
                            }
                        }
                    }
                    //Formar una cuarta parte de la matriz
                    const cuarto = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        for (let j = NUMANILLOS - 1; j >= 0; j--) {
                            cuarto[i][j] = anillos[NUMANILLOS - j - 1][i - j];
                            cuarto[j][i] = anillos[NUMANILLOS - j - 1][i - j];
                        }
                    }
                    const completa = new Array(TAMANO).fill().map(_ => new Array(TAMANO).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let reves = cuarto[i].slice().reverse()
                        let fila = (cuarto[i]).concat(reves);

                        if (impar) {
                            fila.splice(NUMANILLOS - 1, 1);
                        }
                        completa[i] = fila//ncuarto[i].reverse().concat(ncuarto[i]);        
                        completa[TAMANO - i - 1] = fila
                    }
                    if (impar) {
                        completa.splice(NUMANILLOS - 1, 1)
                    }
                    return completa;
                }

                this.POSITION_SCORES = crearMCompleta();

                const startTime = performance.now();
                const depth = 4;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                let initScore = this.evaluate(board, this.color);
                const bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity,
                    initScore
                ).move;

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                //console.log("Elapsed Time:", elapsedTime);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta, score) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    console.log(score);
                    return {
                        score,
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);
                    //this.board.move(newBoard, row, col, color);
                    score += this.makeMove(newBoard, row, col, color);


                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta,
                        score
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }
            makeMove(board, row, col, color) {
                this.c += 1;
                let fliped = [];
                let score = 0;
                const TAMANO = board.length;
                const directions = [
                    [0, 1], // right
                    [0, -1], // left
                    [1, 0], // down
                    [-1, 0], // up
                    [1, 1], // diagonal down-right
                    [1, -1], // diagonal down-left
                    [-1, 1], // diagonal up-right
                    [-1, -1], // diagonal up-left
                ];
                board[row][col] = color
                var rcolor = color == 'W' ? 'B' : 'W'
                for (let i = 0; i < directions.length; i++) {
                    let temp = [];
                    const [deltaRow, deltaCol] = directions[i];
                    let currentRow = row + deltaRow;
                    let currentCol = col + deltaCol;
                    if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                        while (board[currentRow][currentCol] == rcolor) {
                            temp.push([currentRow, currentCol]);
                            if (currentRow + deltaRow < TAMANO && currentRow + deltaRow >= 0 && currentCol + deltaCol < TAMANO && currentCol + deltaCol >= 0) {
                                currentRow = currentRow + deltaRow;
                                currentCol = currentCol + deltaCol;
                            } else {
                                break;
                            }
                            if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                                if (board[currentRow][currentCol] == color) {
                                    fliped.push(temp);
                                    //Voltear las piezas
                                    for (let k = 0; k < temp.length; k++) {
                                        const [x, y] = temp[k];
                                        board[x][y] = color;
                                        score += this.POSITION_SCORES[x][y];
                                    }
                                }
                            }
                        }
                    }
                }
                return score;
            }

            evaluate(board, color) {
                //console.log(1);
                let ocolor = "";
                if (color === "W") {
                    ocolor === "B";
                } else {
                    ocolor === "B";
                }

                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 2; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;


                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += this.POSITION_SCORES[i][j];

                        } else if (board[i][j] !== " ") {
                            opponentScore += 1//this.POSITION_SCORES[i][j];                    
                        }
                    }
                }
                playerMoves = this.board.valid_moves(board, color).length;
                opponentMoves = this.board.valid_moves(board, ocolor).length;
                const playerScoreTotal =
                    playerScore +
                    playerMoves * mobilityValue

                const opponentScoreTotal =
                    opponentScore +
                    opponentMoves * mobilityValue

                return playerScoreTotal - opponentScoreTotal;
            }
        }

        class EEAPlayerNew extends Agent {
            constructor() {
                super();
                this.board = new Board();
                this.POSITION_SCORES = [];
                this.c = 0;
            }

            compute(board, time) {
                function crearMCompleta() {
                    let TAMANO = board.length;
                    let impar = false;
                    if (TAMANO % 2 != 0) {
                        impar = true;
                        TAMANO += 1;
                    }
                    const NUMANILLOS = TAMANO / 2;
                    const anillos = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    let caso1 = false;
                    if (TAMANO % 4 == 0) {
                        caso1 = true;
                    }
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let numPartesAnillo = (i + 1);
                        for (let j = 0; j < numPartesAnillo; j++) {
                            //El tamao del tablero es divisible por 4? 
                            if (caso1) {
                                if (i % 2 != 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 == 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            }
                            //El tamao del tablero no es divisible por 4?
                            if (!caso1) {
                                if (i % 2 == 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 != 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            } else if (i == 0) {
                                anillos[0][j] = 2;
                            } if (i == NUMANILLOS - 1) {
                                anillos[i][0] = (NUMANILLOS + 1) * 5;
                                anillos[i][1] = 0;
                                anillos[i][2] = numPartesAnillo + 2;
                            }
                        }
                    }
                    //Formar una cuarta parte de la matriz
                    const cuarto = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        for (let j = NUMANILLOS - 1; j >= 0; j--) {
                            cuarto[i][j] = anillos[NUMANILLOS - j - 1][i - j];
                            cuarto[j][i] = anillos[NUMANILLOS - j - 1][i - j];
                        }
                    }
                    const completa = new Array(TAMANO).fill().map(_ => new Array(TAMANO).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let reves = cuarto[i].slice().reverse()
                        let fila = (cuarto[i]).concat(reves);

                        if (impar) {
                            fila.splice(NUMANILLOS - 1, 1);
                        }
                        completa[i] = fila//ncuarto[i].reverse().concat(ncuarto[i]);        
                        completa[TAMANO - i - 1] = fila
                    }
                    if (impar) {
                        completa.splice(NUMANILLOS - 1, 1)
                    }
                    return completa;
                }

                this.POSITION_SCORES = crearMCompleta();

                const startTime = performance.now();
                const depth = 4;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                let initScore = this.evaluate(board, this.color);
                const bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity,
                    initScore
                ).move;

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                //console.log("Elapsed Time:", elapsedTime);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta, score) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {

                    return {
                        bestScore,
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);
                    //this.board.move(newBoard, row, col, color);
                    score += this.makeMove(newBoard, row, col, color);


                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }
                console.log(bestScore, bestMove)
                return {

                    score: bestScore,
                    move: bestMove,
                };
            }
            makeMove(board, row, col, color) {
                this.c += 1;
                let fliped = [];
                let score = 0;
                const TAMANO = board.length;
                const directions = [
                    [0, 1], // right
                    [0, -1], // left
                    [1, 0], // down
                    [-1, 0], // up
                    [1, 1], // diagonal down-right
                    [1, -1], // diagonal down-left
                    [-1, 1], // diagonal up-right
                    [-1, -1], // diagonal up-left
                ];
                board[row][col] = color
                var rcolor = color == 'W' ? 'B' : 'W'
                for (let i = 0; i < directions.length; i++) {
                    let temp = [];
                    const [deltaRow, deltaCol] = directions[i];
                    let currentRow = row + deltaRow;
                    let currentCol = col + deltaCol;
                    if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                        while (board[currentRow][currentCol] == rcolor) {
                            temp.push([currentRow, currentCol]);
                            if (currentRow + deltaRow < TAMANO && currentRow + deltaRow >= 0 && currentCol + deltaCol < TAMANO && currentCol + deltaCol >= 0) {
                                currentRow = currentRow + deltaRow;
                                currentCol = currentCol + deltaCol;
                            } else {
                                break;
                            }
                            if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                                if (board[currentRow][currentCol] == color) {
                                    fliped.push(temp);
                                    //Voltear las piezas
                                    for (let k = 0; k < temp.length; k++) {
                                        const [x, y] = temp[k];
                                        board[x][y] = color;
                                        score += 1;//this.POSITION_SCORES[x][y];
                                    }
                                }
                            }
                        }
                    }
                }
                return score;
            }

            evaluate(board, color) {
                //console.log(1);
                let ocolor = "";
                if (color === "W") {
                    ocolor === "B";
                } else {
                    ocolor === "B";
                }

                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 2; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;


                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += 1//this.POSITION_SCORES[i][j];

                        } else if (board[i][j] !== " ") {
                            opponentScore += 1//this.POSITION_SCORES[i][j];                    
                        }
                    }
                }
                playerMoves = this.board.valid_moves(board, color).length;
                opponentMoves = this.board.valid_moves(board, ocolor).length;
                const playerScoreTotal =
                    playerScore //+playerMoves * mobilityValue

                const opponentScoreTotal =
                    opponentScore //+opponentMoves * mobilityValue

                return playerScoreTotal;// - opponentScoreTotal;
            }
        }
        class EEAPlayerNo extends Agent {
            constructor() {
                super();
                this.board = new Board();
                this.POSITION_SCORES = [];
                this.playerScore = 2;
                this.oponentScore = 2;
            }

            compute(board, time) {
                function crearMCompleta() {
                    let TAMANO = board.length;
                    let impar = false;
                    if (TAMANO % 2 != 0) {
                        impar = true;
                        TAMANO += 1;
                    }
                    const NUMANILLOS = TAMANO / 2;
                    const anillos = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    let caso1 = false;
                    if (TAMANO % 4 == 0) {
                        caso1 = true;
                    }
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let numPartesAnillo = (i + 1);
                        for (let j = 0; j < numPartesAnillo; j++) {
                            //El tamao del tablero es divisible por 4? 
                            if (caso1) {
                                if (i % 2 != 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 == 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            }
                            //El tamao del tablero no es divisible por 4?
                            if (!caso1) {
                                if (i % 2 == 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 != 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            } else if (i == 0) {
                                anillos[0][j] = 2;
                            } if (i == NUMANILLOS - 1) {
                                anillos[i][0] = (NUMANILLOS + 1) * 2;
                                anillos[i][1] = 0;
                                anillos[i][2] = numPartesAnillo + 2;
                            }
                        }
                    }
                    //Formar una cuarta parte de la matriz
                    const cuarto = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        for (let j = NUMANILLOS - 1; j >= 0; j--) {
                            cuarto[i][j] = anillos[NUMANILLOS - j - 1][i - j];
                            cuarto[j][i] = anillos[NUMANILLOS - j - 1][i - j];
                        }
                    }
                    const completa = new Array(TAMANO).fill().map(_ => new Array(TAMANO).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let reves = cuarto[i].slice().reverse()
                        let fila = (cuarto[i]).concat(reves);

                        if (impar) {
                            fila.splice(NUMANILLOS - 1, 1);
                        }
                        completa[i] = fila//ncuarto[i].reverse().concat(ncuarto[i]);        
                        completa[TAMANO - i - 1] = fila
                    }
                    if (impar) {
                        completa.splice(NUMANILLOS - 1, 1)
                    }
                    return completa;
                }

                this.POSITION_SCORES = crearMCompleta();

                const startTime = performance.now();
                const depth = 4;
                const moves = this.board.valid_moves(board, this.color);

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                let bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity,
                    2
                ).move;
                if (bestMove === null) {
                    bestMove = moves[0];
                }
                console.log("Player Score: ", this.playerScore);
                console.log("Oponent Score: ", this.oponentScore);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta, nscore) {

                const moves = this.board.valid_moves(board, color);
                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    //console.log(nscore);
                    return {
                        score: nscore,
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);

                    //this.board.move(newBoard, row, col, color);
                    nscore += this.makeMove(newBoard, row, col, color);

                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta,
                        nscore
                    );
                    //console.log(result.score);


                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        this.playerScore = bestScore;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        this.oponentScore = bestScore;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }
                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }
            makeMove(board, row, col, color) {

                let fliped = [];
                let score = 0;
                const TAMANO = board.length;
                const directions = [
                    [0, 1], // right
                    [0, -1], // left
                    [1, 0], // down
                    [-1, 0], // up
                    [1, 1], // diagonal down-right
                    [1, -1], // diagonal down-left
                    [-1, 1], // diagonal up-right
                    [-1, -1], // diagonal up-left
                ];
                board[row][col] = color
                var rcolor = color == 'W' ? 'B' : 'W'
                for (let i = 0; i < directions.length; i++) {
                    let temp = [];
                    const [deltaRow, deltaCol] = directions[i];
                    let currentRow = row + deltaRow;
                    let currentCol = col + deltaCol;
                    if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                        while (board[currentRow][currentCol] == rcolor) {
                            temp.push([currentRow, currentCol]);
                            if (currentRow + deltaRow < TAMANO && currentRow + deltaRow >= 0 && currentCol + deltaCol < TAMANO && currentCol + deltaCol >= 0) {
                                currentRow = currentRow + deltaRow;
                                currentCol = currentCol + deltaCol;
                            } else {
                                break;
                            }
                            if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                                if (board[currentRow][currentCol] == color) {
                                    fliped.push(temp);
                                    //Voltear las piezas
                                    for (let k = 0; k < temp.length; k++) {
                                        const [x, y] = temp[k];
                                        board[x][y] = color;
                                        score += this.POSITION_SCORES[x][y];
                                    }
                                }
                            }
                        }
                    }
                }
                return score;
            }

            evaluate(board, color) {
                //console.log(1);

                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 2; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;


                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += this.POSITION_SCORES[i][j];
                            playerMoves += this.board.valid_moves(board, color).length;
                        } else if (board[i][j] !== " ") {
                            opponentScore += 1//this.POSITION_SCORES[i][j];
                            playerMoves += this.board.valid_moves(board, color).length;
                        }
                    }
                }

                const playerScoreTotal =
                    playerScore +
                    playerMoves * mobilityValue

                const opponentScoreTotal =
                    opponentScore +
                    opponentMoves * mobilityValue

                return playerScoreTotal - opponentScoreTotal;
            }
        }


        class EEAPlayerT extends Agent {
            constructor() {
                super();
                this.board = new Board();
                this.POSITION_SCORES = [];
                this.playerScore = 2;
                this.oponentScore = 2;
            }

            compute(board, time) {
                function crearMCompleta() {
                    let TAMANO = board.length;
                    let impar = false;
                    if (TAMANO % 2 != 0) {
                        impar = true;
                        TAMANO += 1;
                    }
                    const NUMANILLOS = TAMANO / 2;
                    const anillos = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    let caso1 = false;
                    if (TAMANO % 4 == 0) {
                        caso1 = true;
                    }
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let numPartesAnillo = (i + 1);
                        for (let j = 0; j < numPartesAnillo; j++) {
                            //El tamao del tablero es divisible por 4? 
                            if (caso1) {
                                if (i % 2 != 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 == 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            }
                            //El tamao del tablero no es divisible por 4?
                            if (!caso1) {
                                if (i % 2 == 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 != 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            } else if (i == 0) {
                                anillos[0][j] = 2;
                            } if (i == NUMANILLOS - 1) {
                                anillos[i][0] = (NUMANILLOS + 1) * 2;
                                anillos[i][1] = 0;
                                anillos[i][2] = numPartesAnillo + 2;
                            }
                        }
                    }
                    //Formar una cuarta parte de la matriz
                    const cuarto = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        for (let j = NUMANILLOS - 1; j >= 0; j--) {
                            cuarto[i][j] = anillos[NUMANILLOS - j - 1][i - j];
                            cuarto[j][i] = anillos[NUMANILLOS - j - 1][i - j];
                        }
                    }
                    const completa = new Array(TAMANO).fill().map(_ => new Array(TAMANO).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let reves = cuarto[i].slice().reverse()
                        let fila = (cuarto[i]).concat(reves);

                        if (impar) {
                            fila.splice(NUMANILLOS - 1, 1);
                        }
                        completa[i] = fila//ncuarto[i].reverse().concat(ncuarto[i]);        
                        completa[TAMANO - i - 1] = fila
                    }
                    if (impar) {
                        completa.splice(NUMANILLOS - 1, 1)
                    }
                    return completa;
                }

                this.POSITION_SCORES = crearMCompleta();

                const startTime = performance.now();
                const depth = 4;
                const moves = this.board.valid_moves(board, this.color);

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                let bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity,
                    2
                ).move;
                if (bestMove === null) {
                    bestMove = moves[0];
                }
                console.log("Player Score: ", this.playerScore);
                console.log("Oponent Score: ", this.oponentScore);

                return bestMove;
            }

            minimax(board, color, depth, alpha, beta, nscore) {

                const moves = this.board.valid_moves(board, color);
                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    //console.log(nscore);
                    return {
                        score: this.playerScore - this.oponentScore,
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    const [row, col] = moves[i];
                    const newBoard = this.board.clone(board);

                    //this.board.move(newBoard, row, col, color);
                    nscore = this.makeMove(newBoard, row, col, color);

                    const nextColor = color === "W" ? "B" : "W";
                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );
                    //console.log(result.score);


                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        this.playerScore += nscore;
                        this.oponentScore -= nscore;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        this.playerScore -= nscore;
                        this.oponentScore += nscore;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }
                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }
            makeMove(board, row, col, color) {

                let fliped = [];
                let score = 0;
                const TAMANO = board.length;
                const directions = [
                    [0, 1], // right
                    [0, -1], // left
                    [1, 0], // down
                    [-1, 0], // up
                    [1, 1], // diagonal down-right
                    [1, -1], // diagonal down-left
                    [-1, 1], // diagonal up-right
                    [-1, -1], // diagonal up-left
                ];
                board[row][col] = color
                var rcolor = color == 'W' ? 'B' : 'W'
                for (let i = 0; i < directions.length; i++) {
                    let temp = [];
                    const [deltaRow, deltaCol] = directions[i];
                    let currentRow = row + deltaRow;
                    let currentCol = col + deltaCol;
                    if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                        while (board[currentRow][currentCol] == rcolor) {
                            temp.push([currentRow, currentCol]);
                            if (currentRow + deltaRow < TAMANO && currentRow + deltaRow >= 0 && currentCol + deltaCol < TAMANO && currentCol + deltaCol >= 0) {
                                currentRow = currentRow + deltaRow;
                                currentCol = currentCol + deltaCol;
                            } else {
                                break;
                            }
                            if (currentRow < TAMANO && currentRow >= 0 && currentCol < TAMANO && currentCol >= 0) {
                                if (board[currentRow][currentCol] == color) {
                                    fliped.push(temp);
                                    //Voltear las piezas
                                    for (let k = 0; k < temp.length; k++) {
                                        const [x, y] = temp[k];
                                        board[x][y] = color;
                                        score += this.POSITION_SCORES[x][y];
                                    }
                                }
                            }
                        }
                    }
                }
                return score;
            }

            evaluate(board, color) {
                //console.log(1);

                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 2; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;


                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += this.POSITION_SCORES[i][j];
                            playerMoves += this.board.valid_moves(board, color).length;
                        } else if (board[i][j] !== " ") {
                            opponentScore += 1//this.POSITION_SCORES[i][j];
                            playerMoves += this.board.valid_moves(board, color).length;
                        }
                    }
                }

                const playerScoreTotal =
                    playerScore +
                    playerMoves * mobilityValue

                const opponentScoreTotal =
                    opponentScore +
                    opponentMoves * mobilityValue

                return playerScoreTotal - opponentScoreTotal;
            }
        }

        class CustomPlayerMutant extends Agent {
            constructor() {
                super()
                this.board = new Board();
                this.turns = (this.player === 'W' ? 1 : 0);
                this.fase1 = 0;
                this.fase2 = 0;
                this.fase3 = 0;
                this.POSITION_SCORES = [];
            }

            compute(board, time) {
                function crearMCompleta() {
                    let TAMANO = board.length;
                    let impar = false;
                    if (TAMANO % 2 != 0) {
                        impar = true;
                        TAMANO += 1;
                    }
                    const NUMANILLOS = TAMANO / 2;
                    const anillos = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    let caso1 = false;
                    if (TAMANO % 4 == 0) {
                        caso1 = true;
                    }
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let numPartesAnillo = (i + 1);
                        for (let j = 0; j < numPartesAnillo; j++) {
                            //El tamao del tablero es divisible por 4? 
                            if (caso1) {
                                if (i % 2 != 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 == 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            }
                            //El tamao del tablero no es divisible por 4?
                            if (!caso1) {
                                if (i % 2 == 0) {
                                    anillos[i][0] = numPartesAnillo + 2;
                                    anillos[i][j] = numPartesAnillo + 1;
                                } else if (i % 2 != 0) {
                                    anillos[i][0] = 0;
                                    anillos[i][j] = 1;
                                }
                            } else if (i == 0) {
                                anillos[0][j] = 2;
                            } if (i == NUMANILLOS - 1) {
                                anillos[i][0] = (NUMANILLOS + 1) * 2;
                                anillos[i][1] = 0;
                                anillos[i][2] = numPartesAnillo + 2;
                            }
                        }
                    }
                    //Formar una cuarta parte de la matriz
                    const cuarto = new Array(NUMANILLOS).fill().map(_ => new Array(NUMANILLOS).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        for (let j = NUMANILLOS - 1; j >= 0; j--) {
                            cuarto[i][j] = anillos[NUMANILLOS - j - 1][i - j];
                            cuarto[j][i] = anillos[NUMANILLOS - j - 1][i - j];
                        }
                    }
                    const completa = new Array(TAMANO).fill().map(_ => new Array(TAMANO).fill(0));
                    for (let i = 0; i < NUMANILLOS; i++) {
                        let reves = cuarto[i].slice().reverse()
                        let fila = (cuarto[i]).concat(reves);

                        if (impar) {
                            fila.splice(NUMANILLOS - 1, 1);
                        }
                        completa[i] = fila//ncuarto[i].reverse().concat(ncuarto[i]);        
                        completa[TAMANO - i - 1] = fila
                    }
                    if (impar) {
                        completa.splice(NUMANILLOS - 1, 1)
                    }
                    return completa;
                }

                this.POSITION_SCORES = crearMCompleta();
                this.turns += 2;
                this.fase1 = Math.floor((Math.pow(this.size, 2) - 4) / 3);
                this.fase2 = Math.floor(((Math.pow(this.size, 2) - 4) / 3) * 2);
                this.fase3 = Math.floor((Math.pow(this.size, 2)));
                const matrix = this.convert(board);
                return this.alphaBetaMove(matrix, (this.color === 'W' ? 1 : -1), 1);

            }

            copyAndExecute(board, row, col, player) {
                let newBoard = []
                for (let i = 0; i < this.size; i++) {
                    newBoard = [...newBoard, board[i].slice()];
                }


                let j, i, k, l, acumulado = 0;
                //to left
                for (j = col - 1; j >= 0; j--) {
                    if (col - 1 >= 0) {
                        if (newBoard[row][col - 1] === player || newBoard[row][col - 1] === 0) break;
                    }
                    if (newBoard[row][j] === player && j !== col - 1) {
                        for (k = col - 1; k > j; k--)newBoard[row][k] = player;
                        break;
                    }
                    if (newBoard[row][j] === 0 && j !== col - 1) {
                        break;
                    }
                }
                //to right
                for (j = col + 1; j < this.size; j++) {
                    if (col + 1 < this.size) {
                        if (newBoard[row][col + 1] === player || newBoard[row][col + 1] === 0) break;
                    }
                    if (newBoard[row][j] === player && j !== col + 1) {
                        for (k = col + 1; k < j; k++)newBoard[row][k] = player;
                        break;
                    }
                    if (newBoard[row][j] === 0 && j !== col + 1) break;
                }
                //to up
                for (i = row - 1; i >= 0; i--) {
                    if (row - 1 >= 0) {
                        if (newBoard[row - 1][col] === player || newBoard[row - 1][col] === 0) break;
                    }
                    if (newBoard[i][col] === player && i !== row - 1) {
                        for (l = row - 1; l > i; l--)newBoard[l][col] = player;
                        break;
                    }
                    if (newBoard[i][col] === 0 && i !== row - 1) break;
                }
                //to down
                for (i = row + 1; i < this.size; i++) {
                    if (row + 1 < this.size) {
                        if (newBoard[row + 1][col] === player || newBoard[row + 1][col] === 0) break;
                    }
                    if (newBoard[i][col] === player && i !== row + 1) {
                        for (l = row + 1; l < i; l++)newBoard[l][col] = player;
                        break;
                    }
                    if (newBoard[i][col] === 0 && i !== row + 1) break;

                }

                //left-up
                j = col - 2;
                i = row - 2;

                while (j >= 0 && i >= 0) {

                    if (row - 1 >= 0 && col - 1 >= 0) {
                        if (newBoard[row - 1][col - 1] === player || newBoard[row - 1][col - 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row - 1
                        k = col - 1
                        while (l > i && k > j) {
                            newBoard[l][k] = player
                            l--;
                            k--;
                        }
                    };
                    if (newBoard[i][j] === 0) break;
                    j--;
                    i--;
                }

                //left-down
                j = col - 2;
                i = row + 2;

                while (j >= 0 && i < this.size) {

                    if (row - 1 < this.size && col - 1 >= 0) {
                        if (newBoard[row + 1][col - 1] === player || newBoard[row + 1][col - 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row + 1
                        k = col - 1
                        while (l < i && k > j) {
                            newBoard[l][k] = player
                            l++;
                            k--;
                        }
                    }
                    if (newBoard[i][j] === 0) break;
                    j--;
                    i++;
                }
                //right-down
                j = col + 2;
                i = row + 2;

                while (j < this.size && i < this.size) {

                    if (row + 1 < this.size && col + 1 < this.size) {
                        if (newBoard[row + 1][col + 1] === player || newBoard[row + 1][col + 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row + 1
                        k = col + 1
                        while (l < i && k < j) {
                            newBoard[l][k] = player
                            l++;
                            k++;
                        }
                    }
                    if (newBoard[i][j] === 0) break;
                    j++;
                    i++;
                }

                //right-up
                j = col + 2;
                i = row - 2;

                while (j < this.size && i > 0) {

                    if (row - 1 >= 0 && col + 1 < this.size) {
                        if (newBoard[row - 1][col + 1] === player || newBoard[row - 1][col + 1] === 0) break;
                    }
                    if (newBoard[i][j] === player) {
                        l = row - 1
                        k = col + 1
                        while (l > i && k < j) {
                            newBoard[l][k] = player;
                            l--;
                            k++;
                        }
                    }
                    if (newBoard[i][j] === 0) break;
                    j++;
                    i--;
                }

                newBoard[row][col] = player;

                return newBoard;
            }
            alphaBetaMove(board, player, level) {
                if (this.terminal(board) === true) return []
                if (player === 1) {
                    let bestMove, temp;
                    let value = -Infinity;
                    let moves = this.mobility_moves(board, 1);
                    if (moves.length === 0) {
                        this.alphaBetaSearch(board, -1, -Infinity, Infinity, level + 1)
                    } else {
                        for (var i = 0; i < moves.length; i++) {
                            let temp = value;
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, 1);
                            console.log('En alpha beta + : ' + player)
                            console.log(newBoard)
                            value = Math.max(value, this.alphaBetaSearch(newBoard, -1, -Infinity, Infinity, level + 1))
                            if (value > temp) bestMove = moves[i]
                        }
                        return bestMove
                    }
                } else {
                    let bestMove, temp
                    let value = Infinity
                    let moves = this.mobility_moves(board, -1)
                    if (moves.length === 0) {
                        this.alphaBetaSearch(board, 1, -Infinity, Infinity, level + 1)
                    } else {

                        for (var i = 0; i < moves.length; i++) {
                            let temp = value
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, -1);
                            value = Math.min(value, this.alphaBetaSearch(newBoard, 1, -Infinity, Infinity, level + 1))
                            if (value < temp) bestMove = moves[i]
                        }
                        return bestMove
                    }

                }
            }

            alphaBetaSearch(board, player, alpha, beta, level) {
                let i;
                //if (this.turns < this.fase1 && level === 3 || this.size <= 4)return this.heuristicValue2(board,player)
                //if(this.turns >=this.fase1 && this.turns < this.fase2 && level === 3)return this.heuristicValue5(board,player)
                //if((this.turns >=this.fase2 && level === 4) || this.terminal(board))return this.heuristicValue4(board,player)
                if ((this.turns >= 0 && level === 4)) return this.evaluate(board, player)



                if (player === 1) {
                    let value = -Infinity
                    let moves = this.mobility_moves(board, 1)
                    if (moves.length === 0) {
                        return this.alphaBetaSearch(board, -1, alpha, beta, level + 1)
                    } else {
                        for (i = 0; i < moves.length; i++) {
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, player);
                            value = Math.max(value, this.alphaBetaSearch(newBoard, -1, alpha, beta, level + 1))
                            if (value >= beta) return value
                            alpha = Math.max(alpha, value)
                        }
                        return value
                    }
                } else {
                    let value = Infinity
                    let moves = this.mobility_moves(board, -1)
                    if (moves.length === 0) {
                        return this.alphaBetaSearch(board, 1, alpha, beta, level + 1)
                    } else {
                        for (i = 0; i < moves.length; i++) {
                            const [fil, col] = moves[i];
                            const newBoard = this.copyAndExecute(board, fil, col, player);
                            value = Math.min(value, this.alphaBetaSearch(newBoard, 1, alpha, beta, level + 1))
                            if (value <= alpha) return value
                            beta = Math.min(beta, value)
                        }
                        return value
                    }

                }
            }

            // Determines if the state is terminal or not
            terminal(board) {

                var check_one = this.mobility(board, 1);
                var check_two = this.mobility(board, -1);
                return ((check_one === 0) && (check_two === 0));

            }
            mobility(board, player) {
                let moves = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++)
                        if (this.isMove(board, player, i, j)) {
                            moves++;
                        }
                }
                return moves;
            }

            mobility_moves(board, player) {
                let moves = [];
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++)
                        if (this.isMove(board, player, i, j)) {
                            moves = [...moves, [i, j]];
                        }
                }
                return moves;
            }

            isMove(board, player, row, col) {
                let j, i;
                if (board[row][col] !== 0) return false;

                //to left
                for (j = col - 1; j >= 0; j--) {
                    if (col - 1 >= 0) {
                        if (board[row][col - 1] === player || board[row][col - 1] === 0) break;
                    }
                    if (board[row][j] === player && j !== col - 1) return true;
                    if (board[row][j] === 0 && j !== col - 1) break;
                }
                //to right
                for (j = col + 1; j < this.size; j++) {
                    if (col + 1 < this.size) {
                        if (board[row][col + 1] === player || board[row][col + 1] === 0) break;
                    }
                    if (board[row][j] === player && j !== col + 1) return true;
                    if (board[row][j] === 0 && j !== col + 1) break;
                }
                //to up
                for (i = row - 1; i >= 0; i--) {
                    if (row - 1 >= 0) {
                        if (board[row - 1][col] === player || board[row - 1][col] === 0) break;
                    }
                    if (board[i][col] === player && i !== row - 1) return true;
                    if (board[i][col] === 0 && i !== row - 1) break;
                }
                //to down
                for (i = row + 1; i < this.size; i++) {
                    if (row + 1 < this.size) {
                        if (board[row + 1][col] === player || board[row + 1][col] === 0) break;
                    }
                    if (board[i][col] === player && i !== row + 1) return true;
                    if (board[i][col] === 0 && i !== row + 1) break;

                }

                //left-up
                j = col - 2;
                i = row - 2;

                while (j >= 0 && i >= 0) {

                    if (row - 1 >= 0 && col - 1 >= 0) {
                        if (board[row - 1][col - 1] === player || board[row - 1][col - 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true }
                    if (board[i][j] === 0) break;
                    j--;
                    i--;
                }

                //left-down
                j = col - 2;
                i = row + 2;

                while (j >= 0 && i < this.size) {

                    if (row - 1 < this.size && col - 1 >= 0) {
                        if (board[row + 1][col - 1] === player || board[row + 1][col - 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true };
                    if (board[i][j] === 0) break;
                    j--;
                    i++;
                }
                //right-down
                j = col + 2;
                i = row + 2;

                while (j < this.size && i < this.size) {

                    if (row + 1 < this.size && col + 1 < this.size) {
                        if (board[row + 1][col + 1] === player || board[row + 1][col + 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true };
                    if (board[i][j] === 0) break;
                    j++;
                    i++;
                }

                //right-up
                j = col + 2;
                i = row - 2;

                while (j < this.size && i > 0) {

                    if (row - 1 >= 0 && col + 1 < this.size) {
                        if (board[row - 1][col + 1] === player || board[row - 1][col + 1] === 0) break;
                    }
                    if (board[i][j] === player) { return true };
                    if (board[i][j] === 0) break;
                    j++;
                    i--;
                }



                return false;
            }

            inner_coin(board, i, j) {
                if (i - 1 > 0) {
                    if (j - 1 > 0) if (board[i - 1][j - 1] === 0) return false;
                    if (board[i - 1][j] === 0) return false;
                    if (j + 1 < this.size) if (board[i - 1][j + 1] === 0) return false;
                }
                if (j - 1 > 0) if (board[i][j - 1] === 0) return false;
                if (j + 1 < this.size) if (board[i][j + 1] === 0) return false;
                if (i + 1 < this.size) {
                    if (j - 1 > 0) if (board[i + 1][j - 1] === 0) return false;
                    if (board[i + 1][j] === 0) return false;
                    if (j + 1 < this.size) if (board[i + 1][j + 1] === 0) return false;
                }
                return true

            }

            // In case of terminal state returns the value for terminal state


            convert(board) {
                let matrix = [];
                for (let i = 0; i < this.size; i++) {
                    matrix = [...matrix, Array(this.size).fill(0)]
                }
                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board.length; j++) {
                        if (board[i][j] === '') matrix[i][j] = 0;
                        if (board[i][j] === 'W') matrix[i][j] = 1;
                        if (board[i][j] === 'B') matrix[i][j] = -1;
                    }
                }
                console.log(matrix);
                return matrix;
            }

            heuristicValue2(board, player) {
                return (this.mobility(board, player) - this.mobility(board, player * -1)) * player
            }
            heuristicValue3(player) {
                let score = 0

                for (let i = 0; i < 8; i++) {
                    for (let j = 1; j < 8; j++) {
                        score += (this.numberMatrix[i][j] * this.POSITION_SCORES_2[i][j])
                    }
                }
                let mobility_1 = this.mobility(1)
                let mobility_2 = this.mobility(-1)

                if (player === 1) {
                    return (score) + 2 * (mobility_1 - mobility_2)
                } else {
                    return ((score * -1)) + 2 * (mobility_1 - mobility_2)
                }
            }

            heuristicValue4(board, player) {
                let count = 0
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (board[i][j] == player) {
                            count++;
                        }
                    }
                }
                return count * player;
            }

            heuristicValue5(board, player) {
                let value = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (board[i][j] === player && this.inner_coin(board, i, j)) {
                            value++;
                        }
                    }
                }
                return value * player;
            }
            evaluate(board, player) {
                //console.log(1);
                let color = "";
                let rcolor = "";
                if (player === 1) {
                    color = "W";
                    rcolor = "B";
                } else {
                    color = "B";
                    rcolor = "W";
                }

                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 10; // Weight for each possible move
                const cornerValue = 3; // Weight for each piece in a corner
                const edgeValue = 1.5; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;


                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += this.POSITION_SCORES[i][j];
                        } else if (board[i][j] !== " ") {
                            opponentScore += this.POSITION_SCORES[i][j];

                        }
                    }
                }
                playerMoves = this.board.valid_moves(board, color).length;
                playerMoves = this.board.valid_moves(board, rcolor).length;
                const playerScoreTotal =
                    playerScore +
                    playerMoves * mobilityValue

                const opponentScoreTotal =
                    opponentScore + opponentMoves * mobilityValue
                return playerScoreTotal - opponentScoreTotal;
            }
        }
        class EEAPlayerPRONuevo extends Agent {
            constructor() {
                super();
                this.board = new Board();
                this.movesEvaluated = 0;
            }

            compute(board, time) {
                const startTime = performance.now();
                const depth = 4;

                // Use the Minimax algorithm with alpha-beta pruning to find the best move
                const bestMove = this.minimax(
                    board,
                    this.color,
                    depth,
                    -Infinity,
                    Infinity
                ).move;

                const endTime = performance.now();
                const elapsedTime = endTime - startTime;
                // testing
                // console.log("Elapsed Time:", elapsedTime);

                return bestMove;
            }

            newBoard(board, color, row, col) {
                const newBoard = this.board.clone(board);
                newBoard[row][col] = color;
                return newBoard;
            }

            minimax(board, color, depth, alpha, beta) {
                const moves = this.board.valid_moves(board, color);

                // Maximum depth or no left moves
                if (depth === 0 || moves.length === 0) {
                    return {
                        score: this.evaluate2(board, this.color),
                        move: null,
                    };
                }

                let bestScore = color === this.color ? -Infinity : Infinity;
                let bestMove = null;

                for (let i = 0; i < moves.length; i++) {
                    this.movesEvaluated++;
                    const [row, col] = moves[i];

                    const newBoard = this.newBoard(board, color, row, col);
                    // const newBoard = this.board.clone(board);
                    // this.board.move(newBoard, row, col, color);

                    const nextColor = color === "W" ? "B" : "W";

                    const result = this.minimax(
                        newBoard,
                        nextColor,
                        depth - 1,
                        alpha,
                        beta
                    );

                    if (color === this.color && result.score > bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        alpha = Math.max(alpha, bestScore);
                    } else if (color !== this.color && result.score < bestScore) {
                        bestScore = result.score;
                        bestMove = moves[i];
                        beta = Math.min(beta, bestScore);
                    }

                    if (beta <= alpha) {
                        // Beta cutoff (pruning)
                        break;
                    }
                }

                return {
                    score: bestScore,
                    move: bestMove,
                };
            }

            evaluate2(board, color) {
                // Simple evaluation function that counts the number of pieces for the player
                // and subtracts the number of pieces for the opponent
                let playerScore = 0;
                let opponentScore = 0;

                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore++;
                        } else if (board[i][j] !== " ") {
                            opponentScore++;
                        }
                    }
                }

                return playerScore - opponentScore;
            }

            evaluate(board, color) {
                const pieceValue = 1; // Weight for each piece on the board
                const mobilityValue = 0.4; // Weight for each possible move
                const cornerValue = 13; // Weight for each piece in a corner
                const edgeValue = 7; // Weight for each piece on an edge

                let playerScore = 0;
                let opponentScore = 0;
                let playerMoves = 0;
                let opponentMoves = 0;
                let playerCorners = 0;
                let opponentCorners = 0;
                let playerEdges = 0;
                let opponentEdges = 0;

                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] === color) {
                            playerScore += pieceValue;
                            playerMoves += this.board.valid_moves(board, color).length;

                            if (
                                (i === 0 && j === 0) ||
                                (i === 0 && j === board[i].length - 1) ||
                                (i === board.length - 1 && j === 0) ||
                                (i === board.length - 1 && j === board[i].length - 1)
                            ) {
                                playerCorners += cornerValue;
                            } else if (
                                i === 0 ||
                                j === 0 ||
                                i === board.length - 1 ||
                                j === board[i].length - 1
                            ) {
                                playerEdges += edgeValue;
                            }
                        } else if (board[i][j] !== " ") {
                            opponentScore += pieceValue;
                            opponentMoves += this.board.valid_moves(board, color).length;

                            if (
                                (i === 0 && j === 0) ||
                                (i === 0 && j === board[i].length - 1) ||
                                (i === board.length - 1 && j === 0) ||
                                (i === board.length - 1 && j === board[i].length - 1)
                            ) {
                                opponentCorners += cornerValue;
                            } else if (
                                i === 0 ||
                                j === 0 ||
                                i === board.length - 1 ||
                                j === board[i].length - 1
                            ) {
                                opponentEdges += edgeValue;
                            }
                        }
                    }
                }

                const playerScoreTotal =
                    playerScore +
                    playerMoves * mobilityValue +
                    playerCorners +
                    playerEdges;
                const opponentScoreTotal =
                    opponentScore +
                    opponentMoves * mobilityValue +
                    opponentCorners +
                    opponentEdges;

                return playerScoreTotal - opponentScoreTotal;
            }
        }
        /*
        * Environment (Cannot be modified or any of its attributes accesed directly)
        */
        class Environment extends MainClient {
            constructor() {
                super()
                this.board = new Board()
                this.players = { // Here we are going to set all the players name : instance of class
                    //'jugador1': new RandomPlayer(),
                    'jugador1': new EEAPlayerT(),
                    'jugador2': new CustomPlayerMutant(),
                    'player': new EEAPlayerNo(),
                    'sergio1': new EEAPlayer(),
                    'Random': new RandomPlayer(),
                    "Gabriel1": new EEAPlayerG(),
                    "SergioNuevo": new EEAPlayerPRONuevo()

                }
            }

            // Initializes the game
            init() {
                var white = Konekti.vc('W').value // Name of competitor with white pieces
                var black = Konekti.vc('B').value // Name of competitor with black pieces
                var time = 1000 * parseInt(Konekti.vc('time').value) // Maximum playing time assigned to a competitor (milliseconds)
                var size = parseInt(Konekti.vc('size').value) // Size of the reversi board

                this.size = size
                this.b = this.board.init(size)
                this.board.print(this.b)
                var b1 = this.board.clone(this.b)
                var b2 = this.board.clone(this.b)

                this.white = white
                this.black = black
                this.time = { 'W': time, 'B': time }
                Konekti.vc('W_time').innerHTML = '' + time
                Konekti.vc('B_time').innerHTML = '' + time
                this.player = 'W'
                this.winner = ''

                this.players[white].init('W', b1, time)
                this.players[black].init('B', b2, time)
            }

            // Listen to play button
            play() {
                var TIME = 10
                var x = this
                var board = x.board
                x.player = 'W'
                Konekti.vc('log').innerHTML = 'The winner is...'

                x.init()
                var start = -1

                function clock() {
                    if (x.winner != '') return
                    if (start == -1) setTimeout(clock, TIME)
                    else {
                        var end = Date.now()
                        var ellapsed = end - start
                        var remaining = x.time[x.player] - ellapsed
                        Konekti.vc(x.player + '_time').innerHTML = remaining
                        Konekti.vc((x.player == 'W' ? 'B' : 'W') + '_time').innerHTML = x.time[x.player == 'W' ? 'B' : 'W']

                        if (remaining <= 0) x.winner = (x.player == 'W' ? x.black : x.white) + ' since ' + (x.player == 'W' ? x.white : x.black) + 'got time out'
                        else setTimeout(clock, TIME)
                    }
                }

                function compute() {
                    var w = x.player == 'W'
                    var id = w ? x.white : x.black
                    var nid = w ? x.black : x.white
                    var b = board.clone(x.b)
                    start = Date.now()
                    var action = x.players[id].compute(b, x.time[x.player])
                    var end = Date.now()
                    var flag = board.move(x.b, action[0], action[1], x.player)
                    if (!flag) {
                        x.winner = nid + ' ...Invalid move taken by ' + id + ' on row ' + action[0] + ', column ' + action[1]
                    } else {
                        var ellapsed = end - start
                        x.time[x.player] -= ellapsed
                        Konekti.vc(x.player + '_time').innerHTML = '' + x.time[x.player]
                        if (x.time[x.player] <= 0) {
                            x.winner = nid + ' since ' + id + ' got run of time'
                        } else {
                            x.player = w ? 'B' : 'W'
                            if (!board.can_play(x.b, x.player)) {
                                x.player = w ? 'W' : 'B'
                                if (!board.can_play(x.b, x.player)) x.winner = board.winner(x.b, x.white, x.black)
                            }
                        }
                    }

                    board.print(x.b)
                    start = -1
                    if (x.winner == '') setTimeout(compute, TIME)
                    else Konekti.vc('log').innerHTML = 'The winner is ' + x.winner
                }

                board.print(x.b)
                setTimeout(clock, 1000)
                setTimeout(compute, 1000)
            }
        }

        // Drawing commands
        function custom_commands() {
            return [
                {
                    "command": " ", "commands": [
                        {
                            "command": "fillStyle",
                            "color": { "red": 255, "green": 255, "blue": 255, "alpha": 255 }
                        },
                        {
                            "command": "polygon",
                            "x": [0.2, 0.2, 0.8, 0.8],
                            "y": [0.2, 0.8, 0.8, 0.2]
                        }

                    ]
                },
                {
                    "command": "-",
                    "commands": [
                        {
                            "command": "strokeStyle",
                            "color": { "red": 0, "green": 0, "blue": 0, "alpha": 255 }
                        },
                        {
                            "command": "polyline",
                            "x": [0, 0, 1, 1, 0],
                            "y": [0, 1, 1, 0, 0]
                        }
                    ]
                },
                {
                    "command": "B",
                    "commands": [
                        {
                            "command": "fillStyle",
                            "color": { "red": 0, "green": 0, "blue": 0, "alpha": 255 }
                        },
                        {
                            "command": "polygon",
                            "x": [0.2, 0.2, 0.8, 0.8],
                            "y": [0.2, 0.8, 0.8, 0.2]
                        }
                    ]
                },
                {
                    "command": "W",
                    "commands": [
                        {
                            "command": "fillStyle",
                            "color": { "red": 255, "green": 255, "blue": 0, "alpha": 255 }
                        },
                        {
                            "command": "polygon",
                            "x": [0.2, 0.2, 0.8, 0.8],
                            "y": [0.2, 0.8, 0.8, 0.2]
                        },
                    ]
                }
            ]
        }

        // Main function using the Konekti infrastructure
        function KonektiMain() {
            var client = new Environment()
            Konekti.header('title', '', 'Reversi', 3, { 'class': 'w3-black w3-center' })
            Konekti.raw('log', 'The winner is...')
            // Connects the video with the HTML component
            var btn2 = [
                {
                    'plugin': 'raw', 'setup': ["time", '', {
                        'tag': 'input', 'width': '150px', 'class': "w3-bar-item w3-input w3-border w3-round-xlarge",
                        'placeholder': "&#xf252; Time (secs)", 'style': "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
                    }]
                },
                {
                    'plugin': 'raw', 'setup': ["size", '', {
                        'tag': 'input', 'width': '150px', 'class': "w3-bar-item w3-input w3-border w3-round-xlarge",
                        'placeholder': "&#xf00a; Size", 'style': "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
                    }]
                },
                {
                    'plugin': 'raw', 'setup': ["W", '', {
                        'tag': 'input', 'width': '150px', 'class': "w3-bar-item w3-input w3-border w3-round-xlarge",
                        'placeholder': "&#xf10c; White", 'style': "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
                    }]
                },
                {
                    'plugin': 'raw', 'setup': ["W_time", '&#xf252; White', {
                        'width': '150px', 'class': "w3-bar-item w3-input w3-border w3-round-xlarge",
                        'style': "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
                    }]
                },
                {
                    'plugin': 'raw', 'setup': ["B", '', {
                        'tag': 'input', 'width': '150px', 'class': "w3-bar-item w3-input w3-border w3-round-xlarge",
                        'placeholder': "&#xf111; Black", 'style': "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
                    }]
                },
                {
                    'plugin': 'raw', 'setup': ["B_time", '&#xf252; Black', {
                        'width': '150px', 'class': "w3-bar-item w3-input w3-border w3-round-xlarge",
                        'style': "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;"
                    }]
                },
                { 'plugin': 'btn', 'setup': ["play", "fa-play", '', null, { 'title': 'Cara', 'class': 'w3-right' }] }
            ]
            Konekti.navbar('navbar2', btn2, { 'client': 'client', 'method': 'play' }, { 'class': 'w3-black w3-medium' })
            // Connecting the canvas to the HTML component
            var commands = custom_commands()
            Konekti.canvas('canvas', {}, commands, { 'width': '100%', 'height': 'fit' })

        }

    </script>

</body>

</html>